--- /dev/null	2025-10-06 17:28:13
+++ ui/js/net/sora-client.js	2025-10-06 17:22:55
@@ -0,0 +1,382 @@
+import Sora from 'sora-js-sdk';
+
+const encoder = new TextEncoder();
+const BACKOFF_MS = [500, 1000, 2000, 4000, 8000];
+
+function sleep(ms) {
+  return new Promise((resolve) => setTimeout(resolve, ms));
+}
+
+function normaliseUrlList(raw) {
+  if (!raw) return [];
+  if (Array.isArray(raw)) return raw.filter(Boolean);
+  if (typeof raw === 'string') {
+    return raw
+      .split(',')
+      .map((s) => s.trim())
+      .filter(Boolean);
+  }
+  return [];
+}
+
+function formatLatency(latencyMs) {
+  if (latencyMs == null || Number.isNaN(latencyMs)) return 'n/a';
+  return `${latencyMs.toFixed(1)}ms`;
+}
+
+export function createSoraClient(options) {
+  return new SoraDataChannelClient(options);
+}
+
+class SoraDataChannelClient {
+  constructor(options = {}) {
+    const {
+      signalingUrls,
+      channelId,
+      ctrlLabel,
+      stateLabel,
+      metadata = null,
+      debug = false,
+    } = options;
+
+    if (!channelId) throw new Error('channelId is required');
+    if (!ctrlLabel) throw new Error('ctrlLabel is required');
+    if (!stateLabel) throw new Error('stateLabel is required');
+
+    this.signalingUrls = normaliseUrlList(signalingUrls);
+    if (this.signalingUrls.length === 0) {
+      throw new Error('signalingUrls must not be empty');
+    }
+
+    this.channelId = channelId;
+    this.ctrlLabel = ctrlLabel;
+    this.stateLabel = stateLabel;
+    this.metadata = metadata;
+    this.debug = !!debug;
+    this.sdk = options.sdk || (typeof window !== 'undefined' && window.Sora) || Sora;
+
+    if (!this.sdk) {
+      throw new Error('Sora JS SDK not available. Please install sora-js-sdk.');
+    }
+
+    if (typeof window !== 'undefined' && !window.Sora) {
+      window.Sora = this.sdk;
+    }
+
+    this._session = null;
+    this._connection = null;
+    this._loopPromise = null;
+    this._shouldRun = false;
+    this._disconnectResolver = null;
+
+    this._ctrlReady = false;
+    this._stateReady = false;
+
+    this._sendCount = 0;
+    this._recvCount = 0;
+    this._lastStatsLog = 0;
+    this._statsTimer = null;
+    this._lastCtrlSendAt = null;
+    this._latencyMs = null;
+
+    this._listeners = {
+      open: new Set(),
+      close: new Set(),
+      error: new Set(),
+      state: new Set(),
+    };
+
+    this._onDisconnect = this._handleDisconnect.bind(this);
+    this._onDataChannel = this._handleDataChannel.bind(this);
+    this._onMessage = this._handleMessage.bind(this);
+    this._onNotify = this._handleNotify.bind(this);
+    this._onTimeout = this._handleTimeout.bind(this);
+  }
+
+  connect() {
+    if (this._loopPromise) {
+      if (this.debug) console.debug('[sora] connect() ignored (already running)');
+      return;
+    }
+    this._shouldRun = true;
+    this._loopPromise = this._runLoop();
+  }
+
+  async disconnect() {
+    this._shouldRun = false;
+    if (this._session) {
+      try {
+        await this._session.disconnect();
+      } catch (err) {
+        if (this.debug) console.warn('[sora] disconnect error', err);
+      }
+      this._session = null;
+    }
+    if (this._loopPromise) {
+      try {
+        await this._loopPromise;
+      } catch (err) {
+        if (this.debug) console.warn('[sora] disconnect loop error', err);
+      }
+      this._loopPromise = null;
+    }
+    this._clearStatsTimer();
+  }
+
+  isCtrlReady() {
+    return this._ctrlReady;
+  }
+
+  isStateReady() {
+    return this._stateReady;
+  }
+
+  sendCtrl(message) {
+    if (!message || typeof message !== 'object') {
+      throw new Error('sendCtrl expects a JSON-serialisable object');
+    }
+    if (!this._session || !this._ctrlReady) {
+      if (this.debug) console.warn('[sora] drop ctrl message (channel not ready)');
+      return false;
+    }
+    try {
+      const payload = encoder.encode(JSON.stringify(message));
+      this._session.sendMessage(this.ctrlLabel, payload);
+      this._sendCount += 1;
+      this._lastCtrlSendAt = performance.now();
+      this._maybeLogStats();
+      return true;
+    } catch (err) {
+      this._emit('error', err);
+      return false;
+    }
+  }
+
+  onOpen(handler) {
+    return this._addListener('open', handler);
+  }
+
+  onClose(handler) {
+    return this._addListener('close', handler);
+  }
+
+  onError(handler) {
+    return this._addListener('error', handler);
+  }
+
+  onState(handler) {
+    return this._addListener('state', handler);
+  }
+
+  _addListener(event, handler) {
+    if (typeof handler !== 'function') return () => {};
+    const bucket = this._listeners[event];
+    bucket.add(handler);
+    return () => bucket.delete(handler);
+  }
+
+  _emit(event, payload) {
+    const bucket = this._listeners[event];
+    if (!bucket) return;
+    for (const handler of bucket) {
+      try {
+        handler(payload);
+      } catch (err) {
+        console.error('[sora] listener error', event, err);
+      }
+    }
+  }
+
+  async _runLoop() {
+    let attempt = 0;
+    while (this._shouldRun) {
+      attempt += 1;
+      try {
+        await this._connectOnce(attempt);
+        attempt = 0;
+      } catch (err) {
+        if (!this._shouldRun) break;
+        this._emit('error', err);
+        const index = Math.min(attempt - 1, BACKOFF_MS.length - 1);
+        const waitMs = BACKOFF_MS[index];
+        console.warn(`[sora] reconnecting in ${waitMs}ms`, err);
+        await sleep(waitMs);
+      }
+    }
+    this._loopPromise = null;
+  }
+
+  async _connectOnce(attempt) {
+    console.info(`[sora] connecting (attempt ${attempt})`);
+    this._ctrlReady = false;
+    this._stateReady = false;
+    this._clearStatsTimer();
+    this._sendCount = 0;
+    this._recvCount = 0;
+    this._latencyMs = null;
+    this._lastCtrlSendAt = null;
+
+    const connection = this.sdk.connection(this.signalingUrls, this.debug);
+    this._connection = connection;
+
+    const dataChannels = [
+      { label: this.ctrlLabel, direction: 'sendonly', ordered: true },
+      { label: this.stateLabel, direction: 'recvonly', ordered: true },
+    ];
+
+    const options = {
+      audio: false,
+      video: true,
+      multistream: false,
+      spotlight: false,
+      dataChannelSignaling: true,
+      dataChannels,
+    };
+
+    const session = connection.sendrecv(this.channelId, this.metadata, options);
+    this._session = session;
+
+    session.on('disconnect', this._onDisconnect);
+    session.on('timeout', this._onTimeout);
+    session.on('datachannel', this._onDataChannel);
+    session.on('message', this._onMessage);
+    session.on('notify', this._onNotify);
+
+    try {
+      await session.connect();
+    } catch (err) {
+      this._unwireSession(session);
+      this._session = null;
+      throw err;
+    }
+
+    console.info('[sora] Sora connected');
+    this._startStatsTimer();
+    this._emit('open', { ctrl: this.ctrlLabel, state: this.stateLabel });
+
+    await new Promise((resolve) => {
+      this._disconnectResolver = resolve;
+    });
+    this._disconnectResolver = null;
+
+    this._clearStatsTimer();
+    this._emit('close');
+    this._unwireSession(session);
+    this._session = null;
+
+    if (!this._shouldRun) return;
+    throw new Error('disconnected');
+  }
+
+  _unwireSession(session) {
+    try {
+      session.on('disconnect', null);
+      session.on('timeout', null);
+      session.on('datachannel', null);
+      session.on('message', null);
+      session.on('notify', null);
+    } catch (err) {
+      if (this.debug) console.warn('[sora] unwire error', err);
+    }
+  }
+
+  _handleDisconnect(event) {
+    if (this.debug) console.debug('[sora] disconnect', event);
+    if (this._disconnectResolver) {
+      this._disconnectResolver();
+      this._disconnectResolver = null;
+    }
+  }
+
+  _handleTimeout(event) {
+    console.warn('[sora] timeout', event);
+  }
+
+  _handleDataChannel(event) {
+    const channel = event?.datachannel;
+    if (!channel) return;
+    const { label } = channel;
+    channel.binaryType = 'arraybuffer';
+    channel.onopen = () => {
+      if (label === this.ctrlLabel) {
+        this._ctrlReady = true;
+      }
+      if (label === this.stateLabel) {
+        this._stateReady = true;
+      }
+      console.info(`[sora] data channel open: ${label}`);
+    };
+    channel.onclose = () => {
+      if (label === this.ctrlLabel) {
+        this._ctrlReady = false;
+      }
+      if (label === this.stateLabel) {
+        this._stateReady = false;
+      }
+      console.warn(`[sora] data channel closed: ${label}`);
+    };
+    channel.onerror = (err) => {
+      console.error('[sora] data channel error', label, err);
+      this._emit('error', err);
+    };
+  }
+
+  _handleMessage(event) {
+    const { label, data } = event || {};
+    if (label !== this.stateLabel) return;
+
+    let text;
+    if (data instanceof ArrayBuffer) {
+      text = new TextDecoder().decode(new Uint8Array(data));
+    } else if (data instanceof Uint8Array) {
+      text = new TextDecoder().decode(data);
+    } else if (typeof data === 'string') {
+      text = data;
+    } else {
+      return;
+    }
+
+    let payload;
+    try {
+      payload = JSON.parse(text);
+    } catch (err) {
+      console.warn('[sora] invalid JSON from state channel', err);
+      return;
+    }
+
+    if (!payload || payload.t !== 'state') return;
+    this._recvCount += 1;
+    if (this._lastCtrlSendAt != null) {
+      this._latencyMs = performance.now() - this._lastCtrlSendAt;
+    }
+    this._maybeLogStats();
+    this._emit('state', payload);
+  }
+
+  _handleNotify(event) {
+    if (this.debug) console.debug('[sora] notify', event);
+  }
+
+  _maybeLogStats() {
+    const now = performance.now();
+    if (now - this._lastStatsLog < 1000) return;
+    this._lastStatsLog = now;
+    const latency = formatLatency(this._latencyMs);
+    console.info(`[sora] stats #ctrl:${this._sendCount} #state:${this._recvCount} latency:${latency}`);
+  }
+
+  _startStatsTimer() {
+    this._clearStatsTimer();
+    this._statsTimer = setInterval(() => {
+      const latency = formatLatency(this._latencyMs);
+      console.info(`[sora] stats #ctrl:${this._sendCount} #state:${this._recvCount} latency:${latency}`);
+    }, 5000);
+  }
+
+  _clearStatsTimer() {
+    if (this._statsTimer) {
+      clearInterval(this._statsTimer);
+      this._statsTimer = null;
+    }
+  }
+}
